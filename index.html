<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bypass Portal</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: url('https://media.giphy.com/media/3o72FkiKGMGauydfyg/giphy.gif') no-repeat center center fixed; 
            background-size: cover;
            font-family: Arial, sans-serif;
            color: #fff;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }
        .input-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        input {
            width: 300px;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border: none;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background: #ff6347;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
        }
        button:hover {
            background: #e5533d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-box">
            <h1>绕过入口阿三</h1>
            <input type="text" id="linkInput" placeholder="输入解卡密链接">
            <button onclick="executeBypass()">执行绕过</button>
        </div>
        <div id="result" style="margin-top: 20px;"></div>
    </div>

    <iframe id="targetFrame" style="display: none;"></iframe>

    <script>
        async function executeBypass() {
            const link = document.getElementById('linkInput').value;
            if (link) {
                try {
                    // 打开隐藏的 iframe 加载链接
                    const frame = document.getElementById('targetFrame');
                    frame.src = link;
                    await waitForLoad(frame);

                    // 在 iframe 中执行绕过逻辑
                    const result = await bypassLink(frame.contentDocument);
                    document.getElementById('result').innerHTML = `<p>${result}</p>`;
                } catch (error) {
                    document.getElementById('result').innerHTML = `<p>绕过失败：${error.message}</p>`;
                }
            } else {
                alert('请输入一个有效的解卡密链接');
            }
        }

        async function waitForLoad(frame) {
            return new Promise(resolve => {
                frame.onload = () => resolve();
            });
        }

        async function bypassLink(contentDocument) {
  // 优化后的绕过脚本

    const util = {
        sleep: (ms) => new Promise(resolve => setTimeout(resolve, ms)),
        getRecaptchaResponse: async () => {
            while (typeof grecaptcha === 'undefined') {
                await util.sleep(0);
            }
            while (!grecaptcha.getResponse()) {
                await util.sleep(0);
            }
            return grecaptcha.getResponse();
        },
        getTurnstileResponse: async () => {
            while (typeof turnstile === 'undefined') {
                await util.sleep(0);
            }
            while (!turnstile?.getResponse()) {
                await util.sleep(0);
            }
            return turnstile.getResponse();
        },
        linkvertiseSpoof: (link) => new Promise((resolve, reject) => {
            GM.xmlHttpRequest({
                method: "GET",
                url: link,
                headers: { Referer: 'https://linkvertise.com/' },
                onload: (response) => resolve(response.responseText),
                onerror: (error) => reject(error)
            });
        }),
        copyToClipboard: async (text) => {
            try {
                await navigator.clipboard.writeText(text);
                createPopup('卡密已复制到剪切板', '#4CAF50', 3000, 'top');
            } catch (err) {
                console.error('复制到剪切板失败:', err);
            }
        }
    };

    function createPopup(message, color = '#4CAF50', duration = 3000, position = 'bottom') {
        const popup = document.createElement('div');
        popup.innerHTML = message;
        popup.style.position = 'fixed';
        popup.style[position] = '-100px';
        popup.style.left = '50%';
        popup.style.transform = 'translateX(-50%)';
        popup.style.backgroundColor = color;
        popup.style.color = 'white';
        popup.style.padding = '20px';
        popup.style.zIndex = '1000';
        popup.style.borderRadius = '5px';
        popup.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.1)';
        popup.style.transition = `${position} 0.5s ease`;
        document.body.appendChild(popup);
        setTimeout(() => popup.style[position] = '20px', 100);
        setTimeout(() => {
            popup.style[position] = '-100px';
            setTimeout(() => document.body.removeChild(popup), 500);
        }, duration);
    }

    async function copyAndReplaceTextareaContent() {
        const textarea = document.querySelector('textarea[style]');
        if (textarea) {
            let copied = false;
            while (!copied) {
                try {
                    await util.copyToClipboard(textarea.value);
                    copied = true;
                } catch (err) {
                    console.error('复制到剪切板失败:', err);
                    await util.sleep(1500);
                }
            }
            textarea.value = '别看了，卡密在你的剪切板里';
        }
    }

    const antiAdblockRemover = setInterval(removeAntiAdblock, 500);

    if (document.documentElement.innerHTML.includes('you got the key') || document.documentElement.innerHTML.includes('whitelisted')) {
        await copyAndReplaceTextareaContent();
        createPopup('熊猫系统被终结！！！【by：Asan】', '#4CAF50', 3000, 'bottom');
        return '绕过成功';
    } else if (document.documentElement.innerHTML.includes('Server Error')) {
        return '服务器错误';
    } else if (document.documentElement.innerHTML.includes('session invalidated')) {
        window.location.reload();
        return '会话无效，重新加载';
    } else if (!document.getElementsByTagName('form').length) {
        const providers = Array.from(document.getElementsByTagName('a'));
        const supportedProviders = ['Linkvertise', 'Short Jambo'];
        for (let provider of providers) {
            const providerName = provider.firstChild.innerHTML;
            if (supportedProviders.includes(providerName)) {
                window.location.assign(provider.href);
                return '跳转到广告供应商';
            }
        }
        throw new Error('没有合适的广告供应');
    }

    async function getAdLink() {
        const form = document.getElementsByTagName('form')[0];
        const data = new FormData(form);
        return new Promise((resolve, reject) => {
            GM.xmlHttpRequest({
                method: "POST",
                url: form.action,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Referer': window.location.href,
                },
                data: new URLSearchParams(data),
                onload: (response) => resolve(response.finalUrl),
                onerror: (error) => reject(error)
            });
        });
    }

    function getDestUrl(link) {
        const url = new URL(encodeURI(link));
        switch (url.hostname) {
            case 'linkvertise.com':
                return atob(url.searchParams.get('r'));
            case 'short-jambo.com':
                return url.search.split('&url=')[1];
            default:
                if ((new URL(window.location.href)).searchParams.get('provider')) {
                    return false;
                } else {
                    throw new Error('没有广告');
                }
        }
    }

    function removeAntiAdblock() {
        try {
            let antiAdblock = document.getElementsByClassName('adblock_title')[0];
            while (antiAdblock.parentElement !== document.body) {
                antiAdblock = antiAdblock.parentElement;
            }
            antiAdblock.remove();
            clearInterval(antiAdblockRemover);
        } catch (e) { }
    }

    const customSleepTimes = {
        'vegax': 6000,
        'laziumtools': 11000,
        'adelhub': 11000,
        'neoxkey': 16000,
        'evon': 9000,
        'bedol_serv': 6000,
        'infinix': 6000,
        'eruditehub': 9000,
        'nexushub': 6000,
    };

    try {
        const currentUrl = new URL(link);
        const hwid = currentUrl.searchParams.get('hwid');
        const service = currentUrl.searchParams.get('service');
        const token = currentUrl.searchParams.get('sessiontoken');
        const provider = currentUrl.searchParams.get('provider');
        const checkpoints = currentUrl.searchParams.get('checkpoints');

        if (document.querySelector('.g-recaptcha')) {
            await util.getRecaptchaResponse();
        }

        if (document.getElementById('cf-turnstile')) {
            await util.getTurnstileResponse();
        }

        const adUrl = await getAdLink();
        let dest = getDestUrl(adUrl);

        if (!dest) {
            window.location.assign(`https://pandadevelopment.net/getkey?service=${service}&hwid=${hwid}`);
            return '跳转到获取密钥页面';
        }

        let sleepTime = customSleepTimes[service] || 0;
        await util.sleep(sleepTime);
        await util.linkvertiseSpoof(dest);

        createPopup('正在绕过！！！', '#4CAF50', 3000, 'top');
        await util.sleep(0);

        const newUrl = new URL(dest);
        const newToken = newUrl.searchParams.get('sessiontoken');

        let nextCheckpoint = `https://pandadevelopment.net/getkey?hwid=${hwid}&service=${service}&sessiontoken=${newToken}&checkpoints=${checkpoints}`;

        if (provider) {
            nextCheckpoint += `&provider=${provider}`;
        }

        window.location.assign(nextCheckpoint);

        return '绕过成功';

    } catch (e) {
        console.error(e);
        return '发生错误';
    }
}          // 这里放置你的复杂绕过逻辑
            // contentDocument 是 iframe 内部文档对象，可以在这里执行操作
            // 例如，可以通过 contentDocument 获取页面内容，进行解析和操作
            // 注意：下面的代码仅作为示例，需要根据你的实际情况进行修改和扩展

            try {
                // 示例中，直接返回 iframe 内容作为演示
                return '绕过成功：' + contentDocument.documentElement.innerHTML;
            } catch (error) {
                throw new Error('绕过失败：' + error.message);
            }
        }
    </script>
</body>
</html>
